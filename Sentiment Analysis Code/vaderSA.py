"""
vaderSA.py

This program uses the csv file generated by pushShift.py to conduct & chart a  
negative/neutral/positive sentiment analysis on the collected dataset using the 
VADER library.

Author: Joseph A. Tomasello 
"""


"""
BEGIN - SCRIPT PREPARATION
"""
import matplotlib.pyplot as mp
import numpy as np
import string
string.punctuation
from datetime import datetime
from dateutil.relativedelta import relativedelta
# from nltk.sentiment.vader import SentimentIntensityAnalyzer
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer
sid = SentimentIntensityAnalyzer()
"""
END - SCRIPT PREPARATION 
"""


"""
BEGIN - FUNCTIONS
"""
# This function generates a sentiment polarity figure and assigns a value of "Negative", 
# "Neutral", or "Postive" to each collected post
def vader_analysis(dataframe):

    # Adds a new column to the dataframe to store a set of sentiment polarity figures 
    # for the CleanBodyText of each collected post
    dataframe["vader_polarity"] = dataframe['clean_body_text'].apply(
        lambda x: sid.polarity_scores( str(x) ) )

    # Adds a new column to the dataframe to store the compound score from the polarity
    # figures
    dataframe['compound'] = dataframe['vader_polarity'].apply(
        lambda score_dict: score_dict['compound'] )

    # Adds a new column to the dataframe to store either a "Negative", "Neutral", or 
    # "Postive" designation
    dataframe['vader_sentiment'] = dataframe['compound'].apply(
        lambda x: translate_vader_sentiment(x) )

# This helper function translates the numerical compound polarity score to a text score 
# reading either "Negative", "Postive", or "Neutral"
def translate_vader_sentiment(compound):

    if compound <= -0.05:
        return "Negative"
    elif compound >= 0.05:
        return "Positive"
    else:
        return "Neutral"

# This function generates and displays a bar plot showcasing the total number of negative, 
# positive, and neutral posts in the entire dataset over the full collection period
def vader_chart_full_bar(dataframe, plot_title):

    sentiment_names_list = ['Negative', 'Positive', 'Neutral']
    bar_colors = ['lightcoral', 'lightgreen', 'lightgrey']

    # Generates and formats the bar plot
    ax = mp.bar(sentiment_names_list, dataframe['vader_sentiment'].value_counts(), color=bar_colors)

    # Disables scientific notation for the values displayed across the x-axis
    mp.ticklabel_format(style='plain', axis='y')

    # fmt='%d' disables scientific notation for the exact value bar labels
    mp.bar_label(ax, fmt='%d')

    # Labels, formats, and displays the bar plot
    mp.title(plot_title)
    mp.xticks(rotation = 45)
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Sentiments')
    mp.ylabel('Number of Posts')
    mp.show()

    return dict(dataframe['vader_sentiment'].value_counts())

# This function generates and displays a simple pie chart showcasing the total number
# of negative, positive, and neutral posts present in the dataset
def vader_chart_full_pie(dataframe, plot_title):

    # Used to set the colors of the pie chart's wedges
    wedge_colors = ['lightcoral', 'lightgreen', 'lightgrey']

    # Generates and formats the pie plot
    dataframe['vader_sentiment'].value_counts().plot(
        kind="pie", 
        autopct=lambda pct: func(pct, dataframe['vader_sentiment'].value_counts()),
        colors=wedge_colors,
        label="" )

    # Labels and displays the pie plot
    mp.title(plot_title)
    mp.show()

    return dict(dataframe['vader_sentiment'].value_counts())

# This helper function creates the autocpt arguments used to append the exact value counts
# to the pie chart generated by the above function
def func(pct, allvalues):
    absolute = int(pct / 100.*np.sum(allvalues))
    return "{:.2f}%\n({:,.0f} Posts)".format(pct, absolute)

# This function creates a catalogue of aggregated sentiment totals within a specified 
# date range using an month-based interval amount
def vader_interval_catalogue(dataframe, interval, start_date, end_date, date_column):

    sentiment_count_dict = {}

    # Loops over the specified date range according to the interval amount
    while start_date < end_date:
  
        # Used to track the total amount of each sentiment over the current interval
        # period
        negative = 0
        positive = 0
        neutral = 0

        # Converts the datetime column to a datetime object, and increments the month
        # component every loop iteration according to the interval amount
        next_date = (datetime.strptime(start_date, '%Y-%m-%d') +
                     relativedelta(months=+interval)).strftime('%Y-%m-%d')

        # This dataframe variable is used to store a new portion of the total dataframe
        # with each loop iteration according to the interval amount
        new_dataframe = dataframe[(dataframe[date_column] > start_date) &
                                  (dataframe[date_column] < next_date)]

        scores = new_dataframe['vader_sentiment'].to_numpy()
        
        # Sums the total amount of each sentiment within the current interval
        for i in scores:
            if i == 'Negative':
                negative += 1
            elif i == 'Positive':
                positive += 1
            elif i == 'Neutral':
                neutral += 1

        # Sets the start date to the beginning of the next interval
        start_date = next_date

        # Creates a dictionary entry to store the total sentiment values for each 
        # interval period
        sentiment_count_dict[start_date] = {'negative': negative,
                                            'positive': positive, 
                                            'neutral': neutral}

    return sentiment_count_dict

# This function charts the sentiment findings over time catalogued by the above
# function to a line graph
def vader_chart_interval_line(sentiment_dict, plot_title):

    # Used to store the values that will be charted on the line plot
    negative_list = []
    positive_list = []
    neutral_list = []

    # Used to isolate the interval dates to label the x-axis
    total_score_key_list = list(sentiment_dict.keys())

    # This loop appends the sentiment values generated for each interval period
    # to the appropriate sentiment list
    for sentiments in sentiment_dict.values():
        for k, v in sentiments.items():
            if k == 'negative':
                negative_list.append(v)
            elif k == 'positive':
                positive_list.append(v)
            elif k == 'neutral':
                neutral_list.append(v)

    # Print each sentiment category with its associated values and dates
    sentiments = {'Negative': negative_list, 'Positive': positive_list, 'Neutral': neutral_list}

    for sentiment, values in sentiments.items():
        print(f"\n{sentiment}:")
        for date, value in zip(total_score_key_list, values):
            print(f"  Date: {date}, Score: {value}")

    # Generates, formats, labels, and displays the line plot
    mp.plot(total_score_key_list, negative_list, label='Negative', color='lightcoral', marker='v')
    mp.plot(total_score_key_list, positive_list, label='Positive', color='lightgreen', marker='o')
    mp.plot(total_score_key_list, neutral_list, label='Neutral', color='lightgrey', marker='s')
    mp.title(plot_title)
    mp.xticks(rotation = 90)
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Month')
    mp.ylabel('Number of Posts')
    mp.legend()
    mp.show()

# This function generates and displays a bar plot showcasing the total number of negative, 
# positive, and neutral posts in the entire dataset over the full collection period
def vader_chart_multiple_bars(plot_title, **kwargs):

    x = np.arange(4)
    sentiment_names_list = ['Negative', 'Positive', 'Neutral']
    sub_name = ''
    sub_name_list = []
    width = 0.2
    negative_list = []
    positive_list = []
    neutral_list = []

    for k, v in kwargs.items():
        count = 0
        sub_name = k
        sub_name_list.append(sub_name)
        for k2, v2 in v.items():
            
            if count == 0:
                negative_list.append(v2)
            if count == 1:
                positive_list.append(v2)
            if count == 2:
                neutral_list.append(v2)
            
            count += 1

    ax = mp.bar(x - 0.2, negative_list, width, color='lightcoral')
    ax2 = mp.bar(x, positive_list, width, color='lightgreen')
    ax3 = mp.bar(x + 0.2, neutral_list, width, color='lightgrey')

    mp.xticks(x, sub_name_list)

    # Disables scientific notation for the values displayed across the x-axis
    mp.ticklabel_format(style='plain', axis='y')

    # fmt='%d' disables scientific notation for the exact value bar labels
    mp.bar_label(ax, fmt='%d')
    mp.bar_label(ax2, fmt='%d')
    mp.bar_label(ax3, fmt='%d')

    # Labels, formats, and displays the bar plot
    mp.title(plot_title)
    #mp.xticks(rotation = 45)
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Sentiment Source')
    mp.ylabel('Number of Posts')
    mp.legend(sentiment_names_list)
    mp.show()

# This function generates and displays a bar plot showcasing the total number of negative, 
# positive, and neutral posts in the entire dataset over the full collection period
def vader_chart_multiple_bars_kw(plot_title, dataframe, kw_list, instance_count):

    #x = np.arange(4)
    sentiment_names_list = ['Negative', 'Positive', 'Neutral']
    width = 0.5
    negative_list = []
    positive_list = []
    neutral_list = []

    for kw in kw_list:
        pos_count = 0
        neg_count = 0
        neu_count = 0
        for index, row in dataframe.iterrows():
            text = str(row['clean_body_text'])
            text_lower = text.lower()
            if  text_lower.count(kw) >= instance_count:
                if row['vader_sentiment'] == 'Positive':
                    pos_count = pos_count + 1
                elif row['vader_sentiment'] == 'Negative':
                    neg_count = neg_count + 1
                elif row['vader_sentiment'] == 'Neutral':
                    neu_count = neu_count + 1
        negative_list.append(neg_count)
        positive_list.append(pos_count)
        neutral_list.append(neu_count)

    print(negative_list)
    print(positive_list)
    print(neutral_list)

    ax = mp.bar(kw_list, negative_list, width, color='lightcoral')
    ax2 = mp.bar(kw_list, positive_list, width, bottom=negative_list, color='lightgreen')
    ax3 = mp.bar(kw_list, neutral_list, width, bottom=np.add(negative_list, positive_list), color='lightgrey')

    #mp.xticks(x, sub_name_list)

    # Disables scientific notation for the values displayed across the x-axis
    #mp.ticklabel_format(style='plain', axis='y')

    # fmt='%d' disables scientific notation for the exact value bar labels
    # mp.bar_label(ax, fmt='%d')
    # mp.bar_label(ax2, fmt='%d')
    # mp.bar_label(ax3, fmt='%d')

    # Labels, formats, and displays the bar plot
    mp.title(plot_title)
    #mp.xticks(rotation = 45)
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Keywords')
    mp.ylabel('Number of Posts')
    mp.legend(sentiment_names_list)
    mp.show()
"""
END - FUNCTIONS
"""
