"""
nrcLexSA.py

This program uses the csv file generated by pushShift.py to conduct/chart a sentiment 
analysis on the collected dataset using NRC Lexicon and its emotion classification 
functionality.

Author: Joseph A. Tomasello
"""


"""
BEGIN - SCRIPT PREPARATION
"""
import matplotlib.pyplot as mp
import numpy as np
import ast
import string
string.punctuation
from nrclex import NRCLex
from datetime import datetime
from dateutil.relativedelta import relativedelta
"""
END - SCRIPT PREPARATION 
"""


"""
BEGIN - FUNCTIONS
"""
# This function generates a set of raw emotion/sentiment scores for each post
def nrc_lexicon_analysis(dataframe):

    # Adds a new column to the dataframe to store a set of emotion/sentiment scores 
    # for the clean_body_text of each collected post
    dataframe["nrc_emotion_scores"] = dataframe['clean_body_text'].apply( 
        lambda x: NRCLex( str(x) ).raw_emotion_scores )

    return dataframe

# This helper function either sums or aggregates the emotion/sentiment scores passed to it
# Note: Accepts both dataframe and dictionary objects
def process_scores(score_container, setting):

    # Used to store the raw scores passed to the function in list form
    scores_list = []

    # Used to store the scores after aggregation
    score_dict = {'fear': [], 'anger': [], 'anticipation': [], 'trust': [], 'surprise': [], 
                  'sadness': [], 'disgust': [], 'joy': [], 'positive': [], 'negative': []}

    # Determines the object type of the score container passed to the function and
    # converts it to an iterable form
    if type(score_container) is dict:
        scores_list = score_container.values()
    else:
        scores_list = score_container['nrc_emotion_scores'].to_numpy()
        
    # Iterates through the list of raw scores and appends them to the score_dict
    for scores in scores_list:

        if type(scores) is str:
            scores = ast.literal_eval(scores)

        '''score_dict['fear'].append(0)
        score_dict['anger'].append(0)
        score_dict['anticipation'].append(0)
        score_dict['trust'].append(0)
        score_dict['surprise'].append(0)
        score_dict['sadness'].append(0)
        score_dict['disgust'].append(0)
        score_dict['joy'].append(0)
        score_dict['positive'].append(0)
        score_dict['negative'].append(0)'''
        
        for k, v in scores.items():
            if k in score_dict.keys():
                score_dict[k].append(v)

    fear_total = sum(score_dict['fear'])
    anger_total = sum(score_dict['anger'])
    anticipation_total = sum(score_dict['anticipation'])
    trust_total = sum(score_dict['trust'])
    surprise_total = sum(score_dict['surprise'])
    sadness_total = sum(score_dict['sadness'])
    disgust_total = sum(score_dict['disgust'])
    joy_total = sum(score_dict['joy'])
    positive_total = sum(score_dict['positive'])
    negative_total = sum(score_dict['negative'])
    emotion_total = fear_total + anger_total + anticipation_total + trust_total + \
        surprise_total + sadness_total + disgust_total + joy_total
    pos_neg_total = positive_total + negative_total
    # Used to sum and output the scores (mainly for full-period charting)
    if setting == 0:
        score_list_out = [fear_total/emotion_total, anger_total/emotion_total, 
                          anticipation_total/emotion_total, trust_total/emotion_total, 
                          surprise_total/emotion_total, sadness_total/emotion_total, 
                          disgust_total/emotion_total, joy_total/emotion_total, 
                          positive_total/pos_neg_total, negative_total/pos_neg_total]
    # Used to output the scores for interval-based charting
    elif setting == 1:
        score_list_out = [score_dict['fear'], score_dict['anger'], 
                          score_dict['anticipation'], score_dict['trust'], 
                          score_dict['surprise'], score_dict['sadness'], 
                          score_dict['disgust'], score_dict['joy'], 
                          score_dict['positive'], score_dict['negative']]

    return score_list_out

# This function generates and displays a horizontal bar plot showcasing the total emotion 
# scores for the entire dataset over the full collection period
def nrc_chart_emotions_full_barh(dataframe, plot_title):

    # Used to sum the scores over the full collection period
    full_period_score_list = process_scores(dataframe, 0)

    # Used to isolate only the emotion scores
    full_period_emotion_list = full_period_score_list[:8]
    
    # Used to set the names of each bar along the y-axis
    emotion_names_list = ['Fear', 'Anger', 'Anticipation', 'Trust',
                          'Surprise', 'Sadness', 'Disgust', 'Joy']

    # Used to set the colors of the bar plot's bars
    bar_colors = ['darkorchid', 'firebrick', 'grey', 'paleturquoise',
                  'yellow', 'royalblue', 'yellowgreen', 'pink']

    # Generates the bar plot
    ax = mp.barh(emotion_names_list, full_period_emotion_list, color=bar_colors)

    # Disables scientific notation for the values displayed across the x-axis
    #mp.ticklabel_format(style='plain', axis='x')

    # fmt='%d' disables scientific notation for the exact value bar labels
    mp.bar_label(ax)

    # Introduces comma separators to the number values displayed across the x-axis
    '''current_values = mp.gca().get_xticks()
    mp.gca().set_xticklabels(['{:,.0f}'.format(x) for x in current_values])'''

    # Labels and displays the bar plot
    mp.title(plot_title)
    mp.xlabel('Percentage of Total Emotion Scores')
    mp.ylabel('Emotions')
    mp.show()

    return full_period_score_list

# This function generates and displays a bar plot showcasing the total general sentiment
# (i.e., positive and negative) scores for the entire dataset over the full collection 
# period
def nrc_chart_pos_neg_full_bar(dataframe, plot_title):

    # Used to sum the scores over the full collection period
    full_period_score_dict = process_scores(dataframe, 0)

    # Used to isolate only the general sentiment scores (i.e., positive and negative)
    full_period_score_list = full_period_score_dict[8:]

    emotion_names_list = ['Positive', 'Negative']
    bar_colors = ['lightgreen', 'lightcoral']

    # Generates, formats, labels, and displays the bar plot
    ax = mp.bar(emotion_names_list, full_period_score_list, color=bar_colors)
    mp.ticklabel_format(style='plain', axis='y')
    mp.bar_label(ax, fmt='%d')
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.title(plot_title)
    mp.xlabel('Sentiment')
    mp.ylabel('Total Sentiment Score')
    mp.show()

    return full_period_score_list

# This function generates and displays a pie plot showcasing the total general sentiment
# (i.e., positive and negative) scores for the entire dataset over the full collection 
# period
def nrc_chart_pos_neg_full_pie(dataframe, plot_title):

    # Used to sum the scores over the full collection period
    full_period_score_dict = process_scores(dataframe, 0)

    # Used to isolate only the general sentiment scores (i.e., positive and negative)
    full_period_score_list = full_period_score_dict[8:]

    emotion_names_list = ['Positive', 'Negative']
    wedge_colors = ['lightgreen', 'lightcoral']

    # Generates, formats, labels, and displays the pie plot
    mp.pie(full_period_score_list, labels=emotion_names_list, colors=wedge_colors,
           autopct=lambda pct: func(pct, full_period_score_list))
    mp.title(plot_title)
    mp.show()

# This function generates and displays a pie plot showcasing the total emotion scores for 
# the entire dataset over the full collection period
def nrc_chart_emotions_full_pie(dataframe, plot_title):

    # Used to sum the scores over the full collection period
    full_period_score_dict = process_scores(dataframe, 0)

    # Used to isolate only the general sentiment scores (i.e., positive and negative)
    full_period_score_list = full_period_score_dict[:8]
    
    emotion_names_list = ['Fear', 'Anger', 'Anticipation', 'Trust',
                          'Surprise', 'Sadness', 'Disgust', 'Joy']

    wedge_colors = ['darkorchid', 'firebrick', 'grey', 'paleturquoise',
                  'yellow', 'royalblue', 'yellowgreen', 'pink']

    # Generates, formats, labels, and displays the pie plot
    mp.pie(full_period_score_list, labels=emotion_names_list, colors=wedge_colors,
           autopct=lambda pct: func(pct, full_period_score_list))
    mp.title(plot_title)
    mp.show()

# This helper function creates the autocpt arguments used to append the exact value counts
# to the pie charts generated by the functions above
def func(pct, allvalues):
    absolute = int(pct / 100.*np.sum(allvalues))
    return "{:.2f}%\n({:,.0f} Points)".format(pct, absolute)

# This function creates a catalogue of aggregated emotion/sentiment totals within a 
# specified date range by using a month-based interval amount
def nrc_interval_catalogue(dataframe, interval, start_date, end_date, date_column):

    score_dict = {}

    # Loops over the specified date range according to the interval amount
    while start_date < end_date:

        # Converts the datetime column to a datetime object, and increments the month
        # component every loop iteration according to the interval amount
        next_date = (datetime.strptime(start_date, '%Y-%m-%d') +
                     relativedelta(months=+interval)).strftime('%Y-%m-%d')

        # Used to store a new portion of the total dataframe with each loop iteration 
        # according to the interval amount
        new_dataframe = dataframe[(dataframe[date_column] > start_date) &
                                  (dataframe[date_column] < next_date)]

        # Creates a list of tallied emotion/sentiment score totals for the current interval
        score_list = process_scores(new_dataframe, 0)

        # Sets the start date to the beginning of the next interval to advance the loop
        start_date = next_date

        # Creates a dictionary entry to store the total emotion/sentiment values for each 
        # interval period
        score_dict[start_date] = {'fear': score_list[0], 'anger': score_list[1],
                                  'anticipation': score_list[2], 'trust': score_list[3], 
                                  'surprise': score_list[4], 'sadness': score_list[5],
                                  'disgust': score_list[6], 'joy': score_list[7], 
                                  'positive': score_list[8], 'negative': score_list[9]}

    return score_dict

# This function generates and displays a line plot showcasing the emotion scores for the entire 
# dataset over a particular interval
def nrc_chart_emotions_interval_line(scores_dict, plot_title):

    # Used to aggregate the scores over the interval period
    score_value_dict = process_scores(scores_dict, 1)

    # Used to isolate only the emotion scores
    score_value_list = score_value_dict[:8]

    # Used to isolate the interval dates to label the x-axis
    score_key_list = list(scores_dict.keys())

    # Generates, formats, labels, and displays the line plot
    mp.plot(score_key_list, score_value_list[0], label='Fear', color='darkorchid', marker='o')
    mp.plot(score_key_list, score_value_list[1], label='Anger', color='firebrick', marker='v')
    mp.plot(score_key_list, score_value_list[2], label='Anticipation', color='grey', marker='s')
    mp.plot(score_key_list, score_value_list[3], label='Trust', color='paleturquoise', marker='d')
    mp.plot(score_key_list, score_value_list[4], label='Surprise', color='yellow', marker='*')
    mp.plot(score_key_list, score_value_list[5], label='Sadness', color='royalblue', marker='P')
    mp.plot(score_key_list, score_value_list[6], label='Disgust', color='yellowgreen', marker='^')
    mp.plot(score_key_list, score_value_list[7], label='Joy', color='pink', marker='p')
    mp.title(plot_title)
    mp.xticks(rotation = 45)
    current_values = mp.gca().get_yticks()
    #mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Month')
    mp.ylabel('Percentage of Total Emotion Score')
    mp.legend()
    mp.show()

# This function generates and displays a line plot showcasing the general sentiment scores
# (i.e., positive and negative) for the entire dataset over a particular interval
def nrc_chart_pos_and_neg_interval_line(scores_dict, plot_title):

    # Used to aggregate the scores over the interval period
    score_value_dict = process_scores(scores_dict, 1)

    # Used to isolate only the general sentiment scores (i.e., positive and negative)
    score_value_list = score_value_dict[8:]

    # Used to isolate the interval dates to label the x-axis
    score_key_list = list(scores_dict.keys())

    # Generates, formats, labels, and displays the line plot
    mp.plot(score_key_list, score_value_list[0], label='Positive', color='lightgreen', marker='o')
    mp.plot(score_key_list, score_value_list[1], label='Negative', color='lightcoral', marker='o')
    mp.title(plot_title)
    mp.xticks(rotation = 45)
    current_values = mp.gca().get_yticks()
    mp.gca().set_yticklabels(['{:,.0f}'.format(x) for x in current_values])
    mp.xlabel('Month')
    mp.ylabel('Sentiment Score')
    mp.legend()
    mp.show()

def nrc_chart_emotions_multiple_bars(plot_title, **kwargs):

    x = np.arange(4)
    sub_name = ''
    sub_name_list = []
    width = 0.2
    fear_list = []
    anger_list = []
    anticipation_list = []
    trust_list = []
    surprise_list = []
    sadness_list = []
    disgust_list = []
    joy_list = []

    for k, v in kwargs.items():
        count = 0
        sub_name = k
        sub_name_list.append(sub_name)
        for i in v:
            
            if count == 0:
                fear_list.append(i)
            if count == 1:
                anger_list.append(i)
            if count == 2:
                anticipation_list.append(i)
            if count == 3:
                trust_list.append(i)
            if count == 4:
                surprise_list.append(i)
            if count == 5:
                sadness_list.append(i)
            if count == 6:
                disgust_list.append(i)
            if count == 7:
                print(i)
                joy_list.append(i)

            count += 1

    mp.bar(x - 0.2, fear_list, width, color='darkorchid')
    mp.bar(x, anger_list, width, color='firebrick')
    mp.bar(x, anticipation_list, width, color='grey')
    mp.bar(x, trust_list, width, color='paleturquoise')
    mp.bar(x, surprise_list, width, color='yellow')
    mp.bar(x, sadness_list, width, color='royalblue')
    mp.bar(x, disgust_list, width, color='yellowgreen')
    mp.bar(x + 0.2, joy_list, width, color='pink')
    
    # Used to set the names of each bar along the y-axis
    emotion_names_list = ['Fear', 'Anger', 'Anticipation', 'Trust',
                          'Surprise', 'Sadness', 'Disgust', 'Joy']

    # Disables scientific notation for the values displayed across the x-axis
    mp.ticklabel_format(style='plain', axis='x')

    # Introduces comma separators to the number values displayed across the x-axis
    current_values = mp.gca().get_xticks()
    mp.gca().set_xticklabels(['{:,.0f}'.format(x) for x in current_values])

    # Labels and displays the bar plot
    mp.title(plot_title)
    mp.xlabel('Total Emotion Score')
    mp.ylabel('Emotion Source')
    mp.legend(emotion_names_list)
    mp.show()
"""
END - FUNCTIONS
"""
